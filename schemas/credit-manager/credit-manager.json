{
  "contract_name": "credit-manager",
  "contract_version": "1.0.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "allowed_coins",
      "allowed_vaults",
      "max_close_factor",
      "max_liquidation_bonus",
      "oracle",
      "owner",
      "red_bank",
      "swapper"
    ],
    "properties": {
      "allowed_coins": {
        "description": "Whitelisted coin denoms approved by governance",
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "allowed_vaults": {
        "description": "Whitelisted vaults approved by governance that implement credit manager's vault interface",
        "type": "array",
        "items": {
          "$ref": "#/definitions/VaultBase_for_String"
        }
      },
      "max_close_factor": {
        "description": "The maximum percent a liquidator can decrease the debt amount of the liquidatee",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "max_liquidation_bonus": {
        "description": "The maximum percent a liquidator can profit from a liquidation action",
        "allOf": [
          {
            "$ref": "#/definitions/Decimal"
          }
        ]
      },
      "oracle": {
        "description": "The Mars Protocol oracle contract. We read prices of assets here.",
        "allOf": [
          {
            "$ref": "#/definitions/OracleBase_for_String"
          }
        ]
      },
      "owner": {
        "description": "The address with privileged access to update config",
        "type": "string"
      },
      "red_bank": {
        "description": "The Mars Protocol money market contract where we borrow assets from",
        "allOf": [
          {
            "$ref": "#/definitions/RedBankBase_for_String"
          }
        ]
      },
      "swapper": {
        "description": "Helper contract for making swaps",
        "allOf": [
          {
            "$ref": "#/definitions/SwapperBase_for_String"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OracleBase_for_String": {
        "type": "string"
      },
      "RedBankBase_for_String": {
        "type": "string"
      },
      "SwapperBase_for_String": {
        "type": "string"
      },
      "VaultBase_for_String": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Mints NFT representing a credit account for user. User can have many.",
        "type": "object",
        "required": [
          "create_credit_account"
        ],
        "properties": {
          "create_credit_account": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update user's position on their credit account",
        "type": "object",
        "required": [
          "update_credit_account"
        ],
        "properties": {
          "update_credit_account": {
            "type": "object",
            "required": [
              "account_id",
              "actions"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              },
              "actions": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/Action"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update contract config constants",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "required": [
              "new_config"
            ],
            "properties": {
              "new_config": {
                "$ref": "#/definitions/ConfigUpdates"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Internal actions only callable by the contract itself",
        "type": "object",
        "required": [
          "callback"
        ],
        "properties": {
          "callback": {
            "$ref": "#/definitions/CallbackMsg"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Action": {
        "description": "The list of actions that users can perform on their positions",
        "oneOf": [
          {
            "description": "Deposit coin of specified denom and amount. Verifies if the correct amount is sent with transaction.",
            "type": "object",
            "required": [
              "deposit"
            ],
            "properties": {
              "deposit": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Withdraw coin of specified denom and amount",
            "type": "object",
            "required": [
              "withdraw"
            ],
            "properties": {
              "withdraw": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Borrow coin of specified amount from Red Bank",
            "type": "object",
            "required": [
              "borrow"
            ],
            "properties": {
              "borrow": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Repay coin of specified amount back to Red Bank",
            "type": "object",
            "required": [
              "repay"
            ],
            "properties": {
              "repay": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Deposit coins into vault strategy",
            "type": "object",
            "required": [
              "vault_deposit"
            ],
            "properties": {
              "vault_deposit": {
                "type": "object",
                "required": [
                  "coins",
                  "vault"
                ],
                "properties": {
                  "coins": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_String"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Withdraw underlying coins from vault",
            "type": "object",
            "required": [
              "vault_withdraw"
            ],
            "properties": {
              "vault_withdraw": {
                "type": "object",
                "required": [
                  "amount",
                  "vault"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_String"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Requests unlocking of shares for a vault with a required lock period",
            "type": "object",
            "required": [
              "vault_request_unlock"
            ],
            "properties": {
              "vault_request_unlock": {
                "type": "object",
                "required": [
                  "amount",
                  "vault"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_String"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Withdraws the assets for unlocking position id from vault. Required time must have elapsed.",
            "type": "object",
            "required": [
              "vault_withdraw_unlocked"
            ],
            "properties": {
              "vault_withdraw_unlocked": {
                "type": "object",
                "required": [
                  "id",
                  "vault"
                ],
                "properties": {
                  "id": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_String"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Pay back debt of a liquidatable rover account for a bonus. Requires specifying 1) the debt denom/amount of what the liquidator wants to payoff and 2) the request coin denom which the liquidatee should have a balance of. The amount returned to liquidator will be the request coin of the amount that precisely matches the value of the debt + a liquidation bonus. The debt amount will be adjusted down if: - Exceeds liquidatee's total debt for denom - Not enough liquidatee request coin balance to match - The value of the debt repaid exceeds the maximum close factor %",
            "type": "object",
            "required": [
              "liquidate_coin"
            ],
            "properties": {
              "liquidate_coin": {
                "type": "object",
                "required": [
                  "debt_coin",
                  "liquidatee_account_id",
                  "request_coin_denom"
                ],
                "properties": {
                  "debt_coin": {
                    "description": "The coin debt that the liquidator wishes to pay back on behalf of the liquidatee. The liquidator must already have these assets in their credit account.",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Coin"
                      }
                    ]
                  },
                  "liquidatee_account_id": {
                    "description": "The credit account id of the one with a liquidation threshold health factor 1 or below",
                    "type": "string"
                  },
                  "request_coin_denom": {
                    "description": "The coin they wish to acquire from the liquidatee (amount returned will include the bonus)",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Perform a swapper with an exact-in amount. Requires slippage allowance %.",
            "type": "object",
            "required": [
              "swap_exact_in"
            ],
            "properties": {
              "swap_exact_in": {
                "type": "object",
                "required": [
                  "coin_in",
                  "denom_out",
                  "slippage"
                ],
                "properties": {
                  "coin_in": {
                    "$ref": "#/definitions/Coin"
                  },
                  "denom_out": {
                    "type": "string"
                  },
                  "slippage": {
                    "$ref": "#/definitions/Decimal"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "CallbackMsg": {
        "description": "Internal actions made by the contract with pre-validated inputs",
        "oneOf": [
          {
            "description": "Withdraw specified amount of coin from credit account; Decrement the token's asset amount;",
            "type": "object",
            "required": [
              "withdraw"
            ],
            "properties": {
              "withdraw": {
                "type": "object",
                "required": [
                  "account_id",
                  "coin",
                  "recipient"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "coin": {
                    "$ref": "#/definitions/Coin"
                  },
                  "recipient": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Borrow specified amount of coin from Red Bank; Increase the token's coin amount and debt shares;",
            "type": "object",
            "required": [
              "borrow"
            ],
            "properties": {
              "borrow": {
                "type": "object",
                "required": [
                  "account_id",
                  "coin"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "coin": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Repay coin of specified amount back to Red Bank; Decrement the token's coin amount and debt shares;",
            "type": "object",
            "required": [
              "repay"
            ],
            "properties": {
              "repay": {
                "type": "object",
                "required": [
                  "account_id",
                  "coin"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "coin": {
                    "$ref": "#/definitions/Coin"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Calculate the account's max loan-to-value health factor. If above 1, emits a `position_changed` event. If 1 or below, raises an error.",
            "type": "object",
            "required": [
              "assert_below_max_l_t_v"
            ],
            "properties": {
              "assert_below_max_l_t_v": {
                "type": "object",
                "required": [
                  "account_id"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Adds list of coins to a vault strategy",
            "type": "object",
            "required": [
              "vault_deposit"
            ],
            "properties": {
              "vault_deposit": {
                "type": "object",
                "required": [
                  "account_id",
                  "coins",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "coins": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Used to update the account balance of vault coins after a vault action has taken place",
            "type": "object",
            "required": [
              "update_vault_coin_balance"
            ],
            "properties": {
              "update_vault_coin_balance": {
                "type": "object",
                "required": [
                  "account_id",
                  "previous_total_balance",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "description": "Account that needs vault coin balance adjustment",
                    "type": "string"
                  },
                  "previous_total_balance": {
                    "description": "Total vault coin balance in Rover",
                    "allOf": [
                      {
                        "$ref": "#/definitions/Uint128"
                      }
                    ]
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Exchanges vault LP shares for assets",
            "type": "object",
            "required": [
              "vault_withdraw"
            ],
            "properties": {
              "vault_withdraw": {
                "type": "object",
                "required": [
                  "account_id",
                  "amount",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "A privileged action only to be used by Rover. Same as `VaultWithdraw` except it bypasses any lockup period restrictions on the vault. Used only in the case position is unhealthy and requires immediate liquidation.",
            "type": "object",
            "required": [
              "vault_force_withdraw"
            ],
            "properties": {
              "vault_force_withdraw": {
                "type": "object",
                "required": [
                  "account_id",
                  "amount",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Requests unlocking of shares for a vault with a lock period",
            "type": "object",
            "required": [
              "vault_request_unlock"
            ],
            "properties": {
              "vault_request_unlock": {
                "type": "object",
                "required": [
                  "account_id",
                  "amount",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "amount": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Withdraws assets from vault for a locked position having a lockup period that has been fulfilled",
            "type": "object",
            "required": [
              "vault_withdraw_unlocked"
            ],
            "properties": {
              "vault_withdraw_unlocked": {
                "type": "object",
                "required": [
                  "account_id",
                  "position_id",
                  "vault"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "position_id": {
                    "$ref": "#/definitions/Uint128"
                  },
                  "vault": {
                    "$ref": "#/definitions/VaultBase_for_Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Pay back debts of a liquidatable rover account for a bonus",
            "type": "object",
            "required": [
              "liquidate_coin"
            ],
            "properties": {
              "liquidate_coin": {
                "type": "object",
                "required": [
                  "debt_coin",
                  "liquidatee_account_id",
                  "liquidator_account_id",
                  "request_coin_denom"
                ],
                "properties": {
                  "debt_coin": {
                    "$ref": "#/definitions/Coin"
                  },
                  "liquidatee_account_id": {
                    "type": "string"
                  },
                  "liquidator_account_id": {
                    "type": "string"
                  },
                  "request_coin_denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Determine health factor improved as a consequence of liquidation event",
            "type": "object",
            "required": [
              "assert_health_factor_improved"
            ],
            "properties": {
              "assert_health_factor_improved": {
                "type": "object",
                "required": [
                  "account_id",
                  "previous_health_factor"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "previous_health_factor": {
                    "$ref": "#/definitions/Decimal"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Perform a swapper with an exact-in amount. Requires slippage allowance %.",
            "type": "object",
            "required": [
              "swap_exact_in"
            ],
            "properties": {
              "swap_exact_in": {
                "type": "object",
                "required": [
                  "account_id",
                  "coin_in",
                  "denom_out",
                  "slippage"
                ],
                "properties": {
                  "account_id": {
                    "type": "string"
                  },
                  "coin_in": {
                    "$ref": "#/definitions/Coin"
                  },
                  "denom_out": {
                    "type": "string"
                  },
                  "slippage": {
                    "$ref": "#/definitions/Decimal"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Used to update the coin balance of account after an async action",
            "type": "object",
            "required": [
              "update_coin_balances"
            ],
            "properties": {
              "update_coin_balances": {
                "type": "object",
                "required": [
                  "account_id",
                  "previous_balances"
                ],
                "properties": {
                  "account_id": {
                    "description": "Account that needs coin balance adjustment",
                    "type": "string"
                  },
                  "previous_balances": {
                    "description": "Total balances for coins in Rover prior to withdraw",
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/Coin"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "ConfigUpdates": {
        "description": "Used when you want to update fields on Instantiate config",
        "type": "object",
        "properties": {
          "account_nft": {
            "type": [
              "string",
              "null"
            ]
          },
          "allowed_coins": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            }
          },
          "allowed_vaults": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "$ref": "#/definitions/VaultBase_for_String"
            }
          },
          "max_close_factor": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "max_liquidation_bonus": {
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "oracle": {
            "anyOf": [
              {
                "$ref": "#/definitions/OracleBase_for_String"
              },
              {
                "type": "null"
              }
            ]
          },
          "owner": {
            "type": [
              "string",
              "null"
            ]
          },
          "red_bank": {
            "anyOf": [
              {
                "$ref": "#/definitions/RedBankBase_for_String"
              },
              {
                "type": "null"
              }
            ]
          },
          "swapper": {
            "anyOf": [
              {
                "$ref": "#/definitions/SwapperBase_for_String"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "OracleBase_for_String": {
        "type": "string"
      },
      "RedBankBase_for_String": {
        "type": "string"
      },
      "SwapperBase_for_String": {
        "type": "string"
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "VaultBase_for_Addr": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "$ref": "#/definitions/Addr"
          }
        },
        "additionalProperties": false
      },
      "VaultBase_for_String": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Owner & account nft address",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Whitelisted vaults",
        "type": "object",
        "required": [
          "allowed_vaults"
        ],
        "properties": {
          "allowed_vaults": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/VaultBase_for_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Whitelisted coins",
        "type": "object",
        "required": [
          "allowed_coins"
        ],
        "properties": {
          "allowed_coins": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "All positions represented by token with value",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The health of the account represented by token",
        "type": "object",
        "required": [
          "health"
        ],
        "properties": {
          "health": {
            "type": "object",
            "required": [
              "account_id"
            ],
            "properties": {
              "account_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate coin balances for all token positions; start_after accepts (account_id, denom)",
        "type": "object",
        "required": [
          "all_coin_balances"
        ],
        "properties": {
          "all_coin_balances": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate debt shares for all token positions; start_after accepts (account_id, denom)",
        "type": "object",
        "required": [
          "all_debt_shares"
        ],
        "properties": {
          "all_debt_shares": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Total debt shares issued for Coin",
        "type": "object",
        "required": [
          "total_debt_shares"
        ],
        "properties": {
          "total_debt_shares": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate total debt shares for all supported coins; start_after accepts denom string",
        "type": "object",
        "required": [
          "all_total_debt_shares"
        ],
        "properties": {
          "all_total_debt_shares": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate all vault positions; start_after accepts (account_id, addr)",
        "type": "object",
        "required": [
          "all_vault_positions"
        ],
        "properties": {
          "all_vault_positions": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Get total vault coin balance in Rover for vault",
        "type": "object",
        "required": [
          "total_vault_coin_balance"
        ],
        "properties": {
          "total_vault_coin_balance": {
            "type": "object",
            "required": [
              "vault"
            ],
            "properties": {
              "vault": {
                "$ref": "#/definitions/VaultBase_for_String"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Enumerate all total vault coin balances; start_after accepts vault addr",
        "type": "object",
        "required": [
          "all_total_vault_coin_balances"
        ],
        "properties": {
          "all_total_vault_coin_balances": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/VaultBase_for_String"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "VaultBase_for_String": {
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "type": "string"
          }
        },
        "additionalProperties": false
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "all_coin_balances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_CoinBalanceResponseItem",
      "type": "array",
      "items": {
        "$ref": "#/definitions/CoinBalanceResponseItem"
      },
      "definitions": {
        "CoinBalanceResponseItem": {
          "type": "object",
          "required": [
            "account_id",
            "amount",
            "denom"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "all_debt_shares": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_SharesResponseItem",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SharesResponseItem"
      },
      "definitions": {
        "SharesResponseItem": {
          "type": "object",
          "required": [
            "account_id",
            "denom",
            "shares"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "denom": {
              "type": "string"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "all_total_debt_shares": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_DebtShares",
      "type": "array",
      "items": {
        "$ref": "#/definitions/DebtShares"
      },
      "definitions": {
        "DebtShares": {
          "type": "object",
          "required": [
            "denom",
            "shares"
          ],
          "properties": {
            "denom": {
              "type": "string"
            },
            "shares": {
              "$ref": "#/definitions/Uint128"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "all_total_vault_coin_balances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_VaultWithBalance",
      "type": "array",
      "items": {
        "$ref": "#/definitions/VaultWithBalance"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VaultBase_for_Addr": {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/Addr"
            }
          },
          "additionalProperties": false
        },
        "VaultWithBalance": {
          "type": "object",
          "required": [
            "balance",
            "vault"
          ],
          "properties": {
            "balance": {
              "$ref": "#/definitions/Uint128"
            },
            "vault": {
              "$ref": "#/definitions/VaultBase_for_Addr"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "all_vault_positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_VaultPositionResponseItem",
      "type": "array",
      "items": {
        "$ref": "#/definitions/VaultPositionResponseItem"
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VaultBase_for_Addr": {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/Addr"
            }
          },
          "additionalProperties": false
        },
        "VaultPosition": {
          "type": "object",
          "required": [
            "state",
            "vault"
          ],
          "properties": {
            "state": {
              "$ref": "#/definitions/VaultPositionState"
            },
            "vault": {
              "$ref": "#/definitions/VaultBase_for_Addr"
            }
          },
          "additionalProperties": false
        },
        "VaultPositionResponseItem": {
          "type": "object",
          "required": [
            "account_id",
            "position"
          ],
          "properties": {
            "account_id": {
              "type": "string"
            },
            "position": {
              "$ref": "#/definitions/VaultPosition"
            }
          },
          "additionalProperties": false
        },
        "VaultPositionState": {
          "type": "object",
          "required": [
            "locked",
            "unlocked",
            "unlocking"
          ],
          "properties": {
            "locked": {
              "$ref": "#/definitions/Uint128"
            },
            "unlocked": {
              "$ref": "#/definitions/Uint128"
            },
            "unlocking": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/VaultUnlockingId"
              }
            }
          },
          "additionalProperties": false
        },
        "VaultUnlockingId": {
          "type": "object",
          "required": [
            "amount",
            "id"
          ],
          "properties": {
            "amount": {
              "description": "Number of vault tokens",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "id": {
              "description": "Unique identifier representing the unlocking position. Needed for `ExecuteMsg::WithdrawUnlocked {}` call.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "allowed_coins": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "allowed_vaults": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_VaultBase_for_String",
      "type": "array",
      "items": {
        "$ref": "#/definitions/VaultBase_for_String"
      },
      "definitions": {
        "VaultBase_for_String": {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConfigResponse",
      "type": "object",
      "required": [
        "max_close_factor",
        "max_liquidation_bonus",
        "oracle",
        "owner",
        "red_bank",
        "swapper"
      ],
      "properties": {
        "account_nft": {
          "type": [
            "string",
            "null"
          ]
        },
        "max_close_factor": {
          "$ref": "#/definitions/Decimal"
        },
        "max_liquidation_bonus": {
          "$ref": "#/definitions/Decimal"
        },
        "oracle": {
          "type": "string"
        },
        "owner": {
          "type": "string"
        },
        "red_bank": {
          "type": "string"
        },
        "swapper": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "health": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "HealthResponse",
      "type": "object",
      "required": [
        "above_max_ltv",
        "liquidatable",
        "liquidation_threshold_adjusted_collateral",
        "max_ltv_adjusted_collateral",
        "total_collateral_value",
        "total_debt_value"
      ],
      "properties": {
        "above_max_ltv": {
          "type": "boolean"
        },
        "liquidatable": {
          "type": "boolean"
        },
        "liquidation_health_factor": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "liquidation_threshold_adjusted_collateral": {
          "$ref": "#/definitions/Decimal"
        },
        "max_ltv_adjusted_collateral": {
          "$ref": "#/definitions/Decimal"
        },
        "max_ltv_health_factor": {
          "anyOf": [
            {
              "$ref": "#/definitions/Decimal"
            },
            {
              "type": "null"
            }
          ]
        },
        "total_collateral_value": {
          "$ref": "#/definitions/Decimal"
        },
        "total_debt_value": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Positions",
      "type": "object",
      "required": [
        "account_id",
        "coins",
        "debts",
        "vaults"
      ],
      "properties": {
        "account_id": {
          "type": "string"
        },
        "coins": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "debts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DebtAmount"
          }
        },
        "vaults": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/VaultPosition"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "DebtAmount": {
          "type": "object",
          "required": [
            "amount",
            "denom",
            "shares"
          ],
          "properties": {
            "amount": {
              "description": "amount of coins",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "denom": {
              "type": "string"
            },
            "shares": {
              "description": "number of shares in debt pool",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "VaultBase_for_Addr": {
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/Addr"
            }
          },
          "additionalProperties": false
        },
        "VaultPosition": {
          "type": "object",
          "required": [
            "state",
            "vault"
          ],
          "properties": {
            "state": {
              "$ref": "#/definitions/VaultPositionState"
            },
            "vault": {
              "$ref": "#/definitions/VaultBase_for_Addr"
            }
          },
          "additionalProperties": false
        },
        "VaultPositionState": {
          "type": "object",
          "required": [
            "locked",
            "unlocked",
            "unlocking"
          ],
          "properties": {
            "locked": {
              "$ref": "#/definitions/Uint128"
            },
            "unlocked": {
              "$ref": "#/definitions/Uint128"
            },
            "unlocking": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/VaultUnlockingId"
              }
            }
          },
          "additionalProperties": false
        },
        "VaultUnlockingId": {
          "type": "object",
          "required": [
            "amount",
            "id"
          ],
          "properties": {
            "amount": {
              "description": "Number of vault tokens",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "id": {
              "description": "Unique identifier representing the unlocking position. Needed for `ExecuteMsg::WithdrawUnlocked {}` call.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    },
    "total_debt_shares": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DebtShares",
      "type": "object",
      "required": [
        "denom",
        "shares"
      ],
      "properties": {
        "denom": {
          "type": "string"
        },
        "shares": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "total_vault_coin_balance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Uint128",
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
